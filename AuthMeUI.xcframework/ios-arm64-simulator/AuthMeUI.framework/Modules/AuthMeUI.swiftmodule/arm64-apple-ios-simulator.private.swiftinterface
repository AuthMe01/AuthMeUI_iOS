// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name AuthMeUI
import AVFoundation
import AudioToolbox
import AuthMe
@_exported import AuthMeUI
import AuthmeNFCKit
import Combine
import Compression
import CoreFoundation
import CoreGraphics
import CoreGraphics/*.CGFloat*/
import CoreMotion
import CoreText
import CryptoKit
import DeveloperToolsSupport
import Foundation
import ImageIO
import QuartzCore
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: AuthMeUI.RenderingEngine) -> AuthMeUI.LottieBackgroundBehavior
  public static func == (a: AuthMeUI.LottieBackgroundBehavior, b: AuthMeUI.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode : Swift.Hashable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AuthMeUI.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: AuthMeUI.LottieLoopMode, rhs: AuthMeUI.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class LottieAnimationView : AuthMeUI.LottieAnimationViewBase {
  @_Concurrency.MainActor(unsafe) public init(animation: AuthMeUI.LottieAnimation?, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, textProvider: any AuthMeUI.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any AuthMeUI.AnimationFontProvider = DefaultFontProvider(), configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  @_Concurrency.MainActor(unsafe) public init(dotLottie: AuthMeUI.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any AuthMeUI.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any AuthMeUI.AnimationFontProvider = DefaultFontProvider(), configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  @_Concurrency.MainActor(unsafe) public init(configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func play(_ mode: AuthMeUI.LottiePlaybackMode.PlaybackMode, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(fromProgress: AuthMeUI.AnimationProgressTime? = nil, toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(fromFrame: AuthMeUI.AnimationFrameTime? = nil, toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(marker: Swift.String, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func play(markers: [Swift.String], completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func stop()
  @_Concurrency.MainActor(unsafe) open func pause()
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor(unsafe) open func play(_ playbackMode: AuthMeUI.LottiePlaybackMode, animationCompletionHandler: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) open func setPlaybackMode(_ playbackMode: AuthMeUI.LottiePlaybackMode, completion: AuthMeUI.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) public var animateLayoutChangesWithCurrentCoreAnimationContext: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var configuration: AuthMeUI.LottieConfiguration {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var valueProviders: [AuthMeUI.AnimationKeypath : any AuthMeUI.AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor(unsafe) public var backgroundBehavior: AuthMeUI.LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animation: AuthMeUI.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animationLoaded: ((_ animationView: AuthMeUI.LottieAnimationView, _ animation: AuthMeUI.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var imageProvider: any AuthMeUI.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var textProvider: any AuthMeUI.AnimationKeypathTextProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var fontProvider: any AuthMeUI.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var loopMode: AuthMeUI.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var currentProgress: AuthMeUI.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var currentFrame: AuthMeUI.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var realtimeAnimationFrame: AuthMeUI.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor(unsafe) public var realtimeAnimationProgress: AuthMeUI.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor(unsafe) public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var currentRenderingEngine: AuthMeUI.RenderingEngine? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var currentPlaybackMode: AuthMeUI.LottiePlaybackMode? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: AuthMeUI.DotLottieFile)
  @_Concurrency.MainActor(unsafe) public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: AuthMeUI.DotLottieFile)
  @_Concurrency.MainActor(unsafe) public func reloadImages()
  @_Concurrency.MainActor(unsafe) public func forceDisplayUpdate()
  @_Concurrency.MainActor(unsafe) public func setValueProvider(_ valueProvider: any AuthMeUI.AnyValueProvider, keypath: AuthMeUI.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) public func getValue(for keypath: AuthMeUI.AnimationKeypath, atFrame: AuthMeUI.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) public func getOriginalValue(for keypath: AuthMeUI.AnimationKeypath, atFrame: AuthMeUI.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) public func logHierarchyKeypaths()
  @_Concurrency.MainActor(unsafe) public func allHierarchyKeypaths() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) public func addSubview(_ subview: AuthMeUI.AnimationSubview, forLayerAt keypath: AuthMeUI.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: AuthMeUI.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor(unsafe) public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: AuthMeUI.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor(unsafe) public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: AuthMeUI.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) public func progressTime(forMarker named: Swift.String) -> AuthMeUI.AnimationProgressTime?
  @_Concurrency.MainActor(unsafe) public func frameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  @_Concurrency.MainActor(unsafe) public func durationFrameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  @objc deinit
}
public class BundleImageProvider : AuthMeUI.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: AuthMeUI.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: AuthMeUI.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension AuthMeUI.BundleImageProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.BundleImageProvider, rhs: AuthMeUI.BundleImageProvider) -> Swift.Bool
}
public class AuthMeAccessToken {
  public init(tokenURL: Foundation.URL, client: Swift.String, secret: Swift.String, customerID: Swift.String)
  public struct Response : Swift.Decodable {
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Error : Swift.Error {
    case invalidStatusCode(Swift.Int?, Foundation.Data?)
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class BaseViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public var keys: [Swift.String] {
    get
  }
  public var string: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.AnimationKeypath, b: AuthMeUI.AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public enum CoordinateSpace : Swift.Int, Swift.Codable, Swift.Sendable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class LottieAnimation : Swift.Codable, Swift.Sendable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: AuthMeUI.AnimationFrameTime
  final public let endFrame: AuthMeUI.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
public protocol AnimationKeypathTextProvider : AnyObject {
  func text(for keypath: AuthMeUI.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
}
@available(*, deprecated, message: "`AnimationKeypathTextProvider` has been deprecated and renamed to `LegacyAnimationTextProvider`. Instead, conform to `AnimationKeypathTextProvider` instead or conform to `LegacyAnimationTextProvider` explicitly.")
public typealias AnimationTextProvider = AuthMeUI.LegacyAnimationTextProvider
public protocol LegacyAnimationTextProvider : AuthMeUI.AnimationKeypathTextProvider {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
extension AuthMeUI.LegacyAnimationTextProvider {
  public func text(for _: AuthMeUI.AnimationKeypath, sourceText _: Swift.String) -> Swift.String?
}
final public class DictionaryTextProvider : AuthMeUI.AnimationKeypathTextProvider, AuthMeUI.LegacyAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func text(for keypath: AuthMeUI.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension AuthMeUI.DictionaryTextProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.DictionaryTextProvider, rhs: AuthMeUI.DictionaryTextProvider) -> Swift.Bool
}
final public class DefaultTextProvider : AuthMeUI.AnimationKeypathTextProvider, AuthMeUI.LegacyAnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  final public func text(for _: AuthMeUI.AnimationKeypath, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension AuthMeUI.DefaultTextProvider : Swift.Equatable {
  public static func == (_: AuthMeUI.DefaultTextProvider, _: AuthMeUI.DefaultTextProvider) -> Swift.Bool
}
final public class LottieLogger {
  public init(assert: @escaping AuthMeUI.LottieLogger.Assert = { condition, message, file, line in
      // If we default to `Swift.assert` directly with `assert: Assert = Swift.assert`,
      // the call will unexpectedly not respect the -O flag and will crash in release
      // https://github.com/apple/swift/issues/60249
      Swift.assert(condition(), message(), file: file, line: line)
    }, assertionFailure: @escaping AuthMeUI.LottieLogger.AssertionFailure = { message, file, line in
      // If we default to `Swift.assertionFailure` directly with
      // `assertionFailure: AssertionFailure = Swift.assertionFailure`,
      // the call will unexpectedly not respect the -O flag and will crash in release
      // https://github.com/apple/swift/issues/60249
      Swift.assertionFailure(message(), file: file, line: line)
    }, warn: @escaping AuthMeUI.LottieLogger.Warn = { message, _, _ in
    }, info: @escaping AuthMeUI.LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: AuthMeUI.LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension AuthMeUI.LottieLogger {
  public static var printToConsole: AuthMeUI.LottieLogger {
    get
  }
}
public protocol AuthMeAuthenticationDelegate : ObjectiveC.NSObjectProtocol {
  func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  func authmeLivenessViewController(didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didFinishVerifyWith result: AuthMeUI.AuthMeLivenessViewController.LivenessResult, isVerifyPass: Swift.Bool)
  func authTWIDFraudResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWIDResult?, error: (any Swift.Error)?)
  func authTWIDResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWIDResult?, error: (any Swift.Error)?)
  func authTWLicenseResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWLicenseResult?, error: (any Swift.Error)?)
  func authTWHealthResult(image: UIKit.UIImage?, result: AuthMe.TWHealthResult?, error: (any Swift.Error)?)
  func authMRZResult(result: AuthMe.MRZResult?, error: (any Swift.Error)?)
  func authTWNResident(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWNResidentResult?, error: (any Swift.Error)?)
  func authJPNIDCard(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.JPNIDCardResult?, error: (any Swift.Error)?)
  func authJPNIDCardNFC(_ result: AuthMe.JPNIDCardNFCResult?, error: (any Swift.Error)?)
  func authJPNDriverLicense(image: UIKit.UIImage?, result: AuthMe.JPNDriverLicenseResult?, error: (any Swift.Error)?)
  func authJPNDriverLicenseNFC(_ result: AuthMe.JPNDriverLicenseNFCResult?, error: (any Swift.Error)?)
  func authJPNResidentCard(image: UIKit.UIImage?, result: AuthMe.JPNResidentCardResult?, error: (any Swift.Error)?)
  func authJPNResidentCardNFC(cardImage: UIKit.UIImage?, result: AuthMe.JPNResidentCardNFCResult?, error: (any Swift.Error)?)
  func authUSAIDCard(image: UIKit.UIImage?, result: AuthMe.USAIDCardResult?, error: (any Swift.Error)?)
  func authUSADriverLicense(image: UIKit.UIImage?, result: AuthMe.USADriverLicenseResult?, error: (any Swift.Error)?)
  func authUSAVisitorVISA(image: UIKit.UIImage?, result: AuthMe.USAVisitorVISAResult?, error: (any Swift.Error)?)
  func authIDNIDCard(image: UIKit.UIImage?, result: AuthMe.IDNIDCardResult?, error: (any Swift.Error)?)
  func authIDNDriverLicense(image: UIKit.UIImage?, result: AuthMe.IDNDriverLicenseResult?, error: (any Swift.Error)?)
  func authINDIDCard(image: UIKit.UIImage?, result: AuthMe.INDIDCardResult?, error: (any Swift.Error)?)
  func authINDDriverLicense(image: UIKit.UIImage?, result: AuthMe.INDDriverLicenseResult?, error: (any Swift.Error)?)
  func authMYIDCard(image: UIKit.UIImage?, result: AuthMe.MYIDCardResult?, error: (any Swift.Error)?)
  func authMYDriverLicense(image: UIKit.UIImage?, result: AuthMe.MYDriverLicenseResult?, error: (any Swift.Error)?)
  func authHKIDCard(image: UIKit.UIImage?, result: AuthMe.HKIDCardResult?, error: (any Swift.Error)?)
  func authHKDriverLicense(image: UIKit.UIImage?, result: AuthMe.HKDriverLicenseResult?, error: (any Swift.Error)?)
  func authUKIDCard(image: UIKit.UIImage?, result: AuthMe.UKIDCardResult?, error: (any Swift.Error)?)
  func authUKDriverLicense(image: UIKit.UIImage?, result: AuthMe.UKDriverLicenseResult?, error: (any Swift.Error)?)
  func authEGIDCard(image: UIKit.UIImage?, result: AuthMe.EGIDCardResult?, error: (any Swift.Error)?)
  func authEGDriverLicense(image: UIKit.UIImage?, result: AuthMe.EGDriverLicenseResult?, error: (any Swift.Error)?)
  func authSAIDCard(image: UIKit.UIImage?, result: AuthMe.SAIDCardResult?, error: (any Swift.Error)?)
  func authSADriverLicense(image: UIKit.UIImage?, result: AuthMe.SADriverLicenseResult?, error: (any Swift.Error)?)
  func authNLIDCard(image: UIKit.UIImage?, result: AuthMe.NLIDCardResult?, error: (any Swift.Error)?)
  func authNLDriverLicense(image: UIKit.UIImage?, result: AuthMe.NLDriverLicenseResult?, error: (any Swift.Error)?)
  func authSGIDCard(image: UIKit.UIImage?, result: AuthMe.SGIDCardResult?, error: (any Swift.Error)?)
  func authSGDriverLicense(image: UIKit.UIImage?, result: AuthMe.SGDriverLicenseResult?, error: (any Swift.Error)?)
  func authMRZResultAndPlaceOfBirthConfirmed(result: AuthMe.MRZResult?, confirmed: Swift.Bool, error: (any Swift.Error)?)
  func personalPrivacyResult(result: Swift.Bool)
  func authenticateCompleted()
}
extension AuthMeUI.AuthMeAuthenticationDelegate {
  public func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  public func authmeLivenessViewController(didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  public func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didFinishVerifyWith result: AuthMeUI.AuthMeLivenessViewController.LivenessResult, isVerifyPass: Swift.Bool)
  public func authTWIDFraudResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWIDResult?, error: (any Swift.Error)?)
  public func authTWIDResult(frontImage _: UIKit.UIImage?, backImage _: UIKit.UIImage?, result _: AuthMe.TWIDResult?, error _: (any Swift.Error)?)
  public func authTWLicenseResult(frontImage _: UIKit.UIImage?, backImage _: UIKit.UIImage?, result _: AuthMe.TWLicenseResult?, error _: (any Swift.Error)?)
  public func authTWHealthResult(image _: UIKit.UIImage?, result _: AuthMe.TWHealthResult?, error _: (any Swift.Error)?)
  public func authMRZResult(result _: AuthMe.MRZResult?, error _: (any Swift.Error)?)
  public func authTWNResident(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.TWNResidentResult?, error: (any Swift.Error)?)
  public func authJPNIDCard(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: AuthMe.JPNIDCardResult?, error: (any Swift.Error)?)
  public func authJPNIDCardNFC(_ result: AuthMe.JPNIDCardNFCResult?, error: (any Swift.Error)?)
  public func authJPNDriverLicense(image: UIKit.UIImage?, result: AuthMe.JPNDriverLicenseResult?, error: (any Swift.Error)?)
  public func authJPNDriverLicenseNFC(_ result: AuthMe.JPNDriverLicenseNFCResult?, error: (any Swift.Error)?)
  public func authJPNResidentCard(image: UIKit.UIImage?, result: AuthMe.JPNResidentCardResult?, error: (any Swift.Error)?)
  public func authJPNResidentCardNFC(cardImage: UIKit.UIImage?, result: AuthMe.JPNResidentCardNFCResult?, error: (any Swift.Error)?)
  public func authUSAIDCard(image: UIKit.UIImage?, result: AuthMe.USAIDCardResult?, error: (any Swift.Error)?)
  public func authUSADriverLicense(image: UIKit.UIImage?, result: AuthMe.USADriverLicenseResult?, error: (any Swift.Error)?)
  public func authUSAVisitorVISA(image: UIKit.UIImage?, result: AuthMe.USAVisitorVISAResult?, error: (any Swift.Error)?)
  public func authIDNIDCard(image: UIKit.UIImage?, result: AuthMe.IDNIDCardResult?, error: (any Swift.Error)?)
  public func authIDNDriverLicense(image: UIKit.UIImage?, result: AuthMe.IDNDriverLicenseResult?, error: (any Swift.Error)?)
  public func authINDIDCard(image: UIKit.UIImage?, result: AuthMe.INDIDCardResult?, error: (any Swift.Error)?)
  public func authINDDriverLicense(image: UIKit.UIImage?, result: AuthMe.INDDriverLicenseResult?, error: (any Swift.Error)?)
  public func authMYIDCard(image: UIKit.UIImage?, result: AuthMe.MYIDCardResult?, error: (any Swift.Error)?)
  public func authMYDriverLicense(image: UIKit.UIImage?, result: AuthMe.MYDriverLicenseResult?, error: (any Swift.Error)?)
  public func authHKIDCard(image: UIKit.UIImage?, result: AuthMe.HKIDCardResult?, error: (any Swift.Error)?)
  public func authHKDriverLicense(image: UIKit.UIImage?, result: AuthMe.HKDriverLicenseResult?, error: (any Swift.Error)?)
  public func authUKIDCard(image: UIKit.UIImage?, result: AuthMe.UKIDCardResult?, error: (any Swift.Error)?)
  public func authUKDriverLicense(image: UIKit.UIImage?, result: AuthMe.UKDriverLicenseResult?, error: (any Swift.Error)?)
  public func authEGIDCard(image: UIKit.UIImage?, result: AuthMe.EGIDCardResult?, error: (any Swift.Error)?)
  public func authEGDriverLicense(image: UIKit.UIImage?, result: AuthMe.EGDriverLicenseResult?, error: (any Swift.Error)?)
  public func authSAIDCard(image: UIKit.UIImage?, result: AuthMe.SAIDCardResult?, error: (any Swift.Error)?)
  public func authSADriverLicense(image: UIKit.UIImage?, result: AuthMe.SADriverLicenseResult?, error: (any Swift.Error)?)
  public func authNLIDCard(image: UIKit.UIImage?, result: AuthMe.NLIDCardResult?, error: (any Swift.Error)?)
  public func authNLDriverLicense(image: UIKit.UIImage?, result: AuthMe.NLDriverLicenseResult?, error: (any Swift.Error)?)
  public func authSGIDCard(image: UIKit.UIImage?, result: AuthMe.SGIDCardResult?, error: (any Swift.Error)?)
  public func authSGDriverLicense(image: UIKit.UIImage?, result: AuthMe.SGDriverLicenseResult?, error: (any Swift.Error)?)
  public func authMRZResultAndPlaceOfBirthConfirmed(result: AuthMe.MRZResult?, confirmed: Swift.Bool, error: (any Swift.Error)?)
  public func personalPrivacyResult(result _: Swift.Bool)
  public func authenticateCompleted()
}
public protocol AuthMePlaygroundDelegate : ObjectiveC.NSObjectProtocol {
  func authmeLivenessViewControllerDidRecognize(result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
}
public protocol AuthMeNFCDelegate : ObjectiveC.NSObjectProtocol {
  func authmeNFCDidRecognize(result: AuthMe.MRZResult?, error: (any Swift.Error)?)
}
public protocol AnimationCacheProvider : AnyObject, Swift.Sendable {
  func animation(forKey: Swift.String) -> AuthMeUI.LottieAnimation?
  func setAnimation(_ animation: AuthMeUI.LottieAnimation, forKey: Swift.String)
  func clearCache()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthMeManager : ObjectiveC.NSObject {
  @objc deinit
  public static let shared: AuthMeUI.AuthMeManager
  public static var version: Swift.String {
    get
  }
  public var UIConfig: AuthMeUI.AuthMeUIConfig
  public var KYCConfig: AuthMeUI.AuthmeKYCConfig
  public func setLocalizedBundle(with bundle: Foundation.Bundle)
  public func setLocalize(localize: AuthMeUI.AuthMeLocalize)
  public var localize: AuthMeUI.AuthMeLocalize {
    get
    set
  }
}
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: AuthMeUI.ColorFormatDenominator, b: AuthMeUI.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieColor : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: AuthMeUI.ColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottieColor, b: AuthMeUI.LottieColor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, subdirectory: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@objc public enum CompatibleRenderingEngineOption : Swift.Int {
  case shared
  case defaultEngine
  case automatic
  case mainThread
  case coreAnimation
  public static func generateLottieConfiguration(_ configuration: AuthMeUI.CompatibleRenderingEngineOption) -> AuthMeUI.LottieConfiguration
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum CompatibleBackgroundBehavior : Swift.Int {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) convenience public init(compatibleAnimation: AuthMeUI.CompatibleAnimation)
  @objc @_Concurrency.MainActor(unsafe) public init(compatibleAnimation: AuthMeUI.CompatibleAnimation, compatibleRenderingEngineOption: AuthMeUI.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor(unsafe) convenience public init(url: Foundation.URL)
  @objc @_Concurrency.MainActor(unsafe) public init(url: Foundation.URL, compatibleRenderingEngineOption: AuthMeUI.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor(unsafe) convenience public init(data: Foundation.Data)
  @objc @_Concurrency.MainActor(unsafe) public init(data: Foundation.Data, compatibleRenderingEngineOption: AuthMeUI.CompatibleRenderingEngineOption)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor(unsafe) final public var compatibleAnimation: AuthMeUI.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var compatibleDictionaryTextProvider: AuthMeUI.CompatibleDictionaryTextProvider? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var duration: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var backgroundMode: AuthMeUI.CompatibleBackgroundBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public func play()
  @objc @_Concurrency.MainActor(unsafe) final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func stop()
  @objc @_Concurrency.MainActor(unsafe) final public func pause()
  @objc @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @objc @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: AuthMeUI.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor(unsafe) final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: AuthMeUI.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func getColorValue(for keypath: AuthMeUI.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: AuthMeUI.AnimationSubview, forLayerAt keypath: AuthMeUI.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: AuthMeUI.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor(unsafe) final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: AuthMeUI.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc final public class CompatibleDictionaryTextProvider : ObjectiveC.NSObject {
  @objc public init(values: [Swift.String : Swift.String])
  @objc deinit
}
extension AuthMeUI.DotLottieFile {
  public enum SynchronouslyBlockingCurrentThread {
    public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>
    public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>
    public static func loadedFrom(data: Foundation.Data, filename: Swift.String) -> Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>
  }
  #if compiler(>=5.3) && $AsyncAwait
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> AuthMeUI.DotLottieFile
  #endif
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> AuthMeUI.DotLottieFile
  #endif
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> AuthMeUI.DotLottieFile
  #endif
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> AuthMeUI.DotLottieFile
  #endif
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, handleResult: @escaping (Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<AuthMeUI.DotLottieFile, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie) async throws -> AuthMeUI.DotLottieFile
  #endif
}
extension Dispatch.DispatchQueue {
  public static let dotLottie: Dispatch.DispatchQueue
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: AuthMeUI.AnyValueProviderStorage { get }
  func hasUpdate(frame: AuthMeUI.AnimationFrameTime) -> Swift.Bool
}
extension AuthMeUI.AnyValueProvider {
  public func value(frame: AuthMeUI.AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : AuthMeUI.AnyInterpolatable {
  case singleValue(T)
  case keyframes([AuthMeUI.Keyframe<T>])
  case closure((AuthMeUI.AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([AuthMeUI.Keyframe<Any>], interpolate: (AuthMeUI.AnimationFrameTime) -> Any)
  case closure((AuthMeUI.AnimationFrameTime) -> Any)
}
public enum AuthMeLocalize : Swift.String {
  case en
  case zh_Hant
  case jp
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DotLottieConfiguration {
  public var id: Swift.String
  public var loopMode: AuthMeUI.LottieLoopMode
  public var speed: Swift.Double
  public var imageProvider: (any AuthMeUI.AnimationImageProvider)? {
    get
  }
}
public struct DotLottieConfigurationComponents : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public static let imageProvider: AuthMeUI.DotLottieConfigurationComponents
  public static let loopMode: AuthMeUI.DotLottieConfigurationComponents
  public static let animationSpeed: AuthMeUI.DotLottieConfigurationComponents
  public static let all: AuthMeUI.DotLottieConfigurationComponents
  public static let none: AuthMeUI.DotLottieConfigurationComponents
  public let rawValue: Swift.Int
  public typealias ArrayLiteralElement = AuthMeUI.DotLottieConfigurationComponents
  public typealias Element = AuthMeUI.DotLottieConfigurationComponents
  public typealias RawValue = Swift.Int
}
final public class ColorValueProvider {
  public init(block: @escaping AuthMeUI.ColorValueProvider.ColorValueBlock)
  public init(_ color: AuthMeUI.LottieColor)
  public init(_ keyframes: [AuthMeUI.Keyframe<AuthMeUI.LottieColor>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> AuthMeUI.LottieColor
  final public var color: AuthMeUI.LottieColor {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: AuthMeUI.ValueProviderStorage<AuthMeUI.LottieColor> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension AuthMeUI.ColorValueProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.ColorValueProvider, rhs: AuthMeUI.ColorValueProvider) -> Swift.Bool
}
public enum AuthmeFeature : Swift.String {
  case TWNIDCardFraud
  case TWNIDCard
  case Passport
  case NFCPassport
  case TWNDriverLicense
  case TWNHealthCard
  case TWNResidentCard
  case JPNID
  case JPNNFCID
  case JPNDriverLicense
  case JPNNFCDriverLicense
  case JPNResidentCard
  case JPNNFCResidentCard
  case USAID
  case USADriverLicense
  case USAVisitorVISA
  case IDNID
  case IDNDriverLicense
  case Liveness
  case PassportWithVIZ
  case INDID
  case INDDriverLicense
  case MYSID
  case MYSDriverLicense
  case HKGID
  case HKGIDFront
  case HKGDriverLicense
  case GBRID
  case GBRDriverLicense
  case EGID
  case EGDriverLicense
  case SAID
  case SADriverLicense
  case NLID
  case NLDriverLicense
  case SGPID
  case SGPDriverLicense
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: AuthMeUI.RenderingEngineOption = .automatic, decodingStrategy: AuthMeUI.DecodingStrategy = .dictionaryBased, colorSpace: CoreGraphics.CGColorSpace = CGColorSpaceCreateDeviceRGB(), reducedMotionOption: AuthMeUI.ReducedMotionOption = .systemReducedMotionToggle)
  public static var shared: AuthMeUI.LottieConfiguration
  public var renderingEngine: AuthMeUI.RenderingEngineOption
  public var decodingStrategy: AuthMeUI.DecodingStrategy
  public var reducedMotionOption: AuthMeUI.ReducedMotionOption
  public var colorSpace: CoreGraphics.CGColorSpace
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottieConfiguration, b: AuthMeUI.LottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AuthMeUICoordinatorDelegate : AnyObject {
  func coordinatorDidFinishScanWithErrorSetting()
  func coordinatorDidFinishScan()
}
final public class AuthMeUICoordinator<T> where T : AuthMe.FrameworkMode {
  weak final public var authDelegate: (any AuthMeUI.AuthMeAuthenticationDelegate)?
  weak final public var delegate: (any AuthMeUI.AuthMeUICoordinatorDelegate)?
  public init(presenter: UIKit.UIViewController, flows: [[any AuthMe.EKYCType]])
  @objc deinit
}
public enum LottiePlaybackMode : Swift.Hashable {
  case paused(at: AuthMeUI.LottiePlaybackMode.PausedState)
  case playing(_: AuthMeUI.LottiePlaybackMode.PlaybackMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case progress(_: AuthMeUI.AnimationProgressTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case frame(_: AuthMeUI.AnimationFrameTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case time(_: Foundation.TimeInterval)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case pause
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromProgress(_: AuthMeUI.AnimationProgressTime?, toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromFrame(_: AuthMeUI.AnimationFrameTime?, toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case marker(_: Swift.String, loopMode: AuthMeUI.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case markers(_: [Swift.String])
  public enum PausedState : Swift.Hashable {
    case currentFrame
    case progress(_: AuthMeUI.AnimationProgressTime)
    case frame(_: AuthMeUI.AnimationFrameTime)
    case time(_: Foundation.TimeInterval)
    case marker(_: Swift.String, position: AuthMeUI.LottieMarkerPosition = .start)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: AuthMeUI.LottiePlaybackMode.PausedState, b: AuthMeUI.LottiePlaybackMode.PausedState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PlaybackMode : Swift.Hashable {
    case fromProgress(_: AuthMeUI.AnimationProgressTime?, toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode)
    case fromFrame(_: AuthMeUI.AnimationFrameTime?, toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode)
    case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode)
    case marker(_: Swift.String, loopMode: AuthMeUI.LottieLoopMode)
    case markers(_: [Swift.String])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: AuthMeUI.LottiePlaybackMode.PlaybackMode, b: AuthMeUI.LottiePlaybackMode.PlaybackMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottiePlaybackMode, b: AuthMeUI.LottiePlaybackMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension AuthMeUI.LottiePlaybackMode {
  public static var paused: AuthMeUI.LottiePlaybackMode {
    get
  }
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toProgress(_ toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toFrame(_ toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode
}
extension AuthMeUI.LottiePlaybackMode.PlaybackMode {
  public static func toProgress(_ toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode.PlaybackMode
  public static func toFrame(_ toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode.PlaybackMode
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottiePlaybackMode.PlaybackMode
}
public enum LottieMarkerPosition : Swift.Hashable {
  case start
  case end
  public static func == (a: AuthMeUI.LottieMarkerPosition, b: AuthMeUI.LottieMarkerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AuthMeUI.AuthMeLivenessViewController : AVFoundation.AVCaptureDataOutputSynchronizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func dataOutputSynchronizer(_ synchronizer: AVFoundation.AVCaptureDataOutputSynchronizer, didOutput synchronizedDataCollection: AVFoundation.AVCaptureSynchronizedDataCollection)
}
extension AuthMeUI.AuthMeLivenessViewController {
  public enum `Type` {
    case passive
    case active
    public static func == (a: AuthMeUI.AuthMeLivenessViewController.`Type`, b: AuthMeUI.AuthMeLivenessViewController.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LivenessResult {
    case succeed(UIKit.UIImage)
    case failed
    case canceled
  }
}
extension AuthMeUI.AuthMeLivenessViewController : AuthMe.LivenessFlowDelegate {
  @_Concurrency.MainActor(unsafe) public func livenessDidStart()
  @_Concurrency.MainActor(unsafe) public func livenessDidNotifyMessage(status: AuthMe.LivenessDetectStatus)
  @_Concurrency.MainActor(unsafe) public func livenessDidUpdateReconize(result: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func livenessDidFailureWith(error: AuthMe.FlowError, retryHandler: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor(unsafe) public func livenessDidRecognize(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func livenessDidFaceScale(direction: AuthMe.LivenessFlow.FaceScaleDirection.Direction)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyStage(log: AuthMe.LogFAS)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyUpload(log: AuthMe.LogUpload)
}
extension UIKit.UIColor {
  public var lottieColorValue: AuthMeUI.LottieColor {
    get
  }
}
public class DefaultAnimationCache : AuthMeUI.AnimationCacheProvider {
  public init()
  public static let sharedCache: AuthMeUI.DefaultAnimationCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func animation(forKey key: Swift.String) -> AuthMeUI.LottieAnimation?
  public func setAnimation(_ animation: AuthMeUI.LottieAnimation, forKey key: Swift.String)
  @objc deinit
}
extension AuthMeUI.DefaultAnimationCache : @unchecked Swift.Sendable {
}
extension AuthMeUI.LottieColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(AuthMeUI.RenderingEngine)
  public static var mainThread: AuthMeUI.RenderingEngineOption {
    get
  }
  public static var coreAnimation: AuthMeUI.RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension AuthMeUI.RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension AuthMeUI.RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public struct LottieButton {
  public init(animation: AuthMeUI.LottieAnimation?, action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public func configure(_ configure: @escaping (AuthMeUI.AnimatedButton) -> Swift.Void) -> AuthMeUI.LottieButton
  public func configuration(_ configuration: AuthMeUI.LottieConfiguration) -> AuthMeUI.LottieButton
  public func animate(fromProgress: AuthMeUI.AnimationProgressTime, toProgress: AuthMeUI.AnimationProgressTime, on event: AuthMeUI.LottieControlEvent) -> AuthMeUI.LottieButton
  public func animate(fromMarker: Swift.String, toMarker: Swift.String, on event: AuthMeUI.LottieControlEvent) -> AuthMeUI.LottieButton
  public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: AuthMeUI.AnimationKeypath) -> AuthMeUI.LottieButton where ValueProvider : AuthMeUI.AnyValueProvider, ValueProvider : Swift.Equatable
  public typealias Body = @_opaqueReturnTypeOf("$s8AuthMeUI12LottieButtonV4bodyQrvp", 0) __
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class LottieAnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public class FilepathImageProvider : AuthMeUI.AnimationImageProvider {
  public init(filepath: Swift.String, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public init(filepath: Foundation.URL, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: AuthMeUI.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: AuthMeUI.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension AuthMeUI.FilepathImageProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.FilepathImageProvider, rhs: AuthMeUI.FilepathImageProvider) -> Swift.Bool
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class AuthMeLivenessViewController : AuthMeUI.BaseViewController {
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any AuthMeUI.AuthMeAuthenticationDelegate)?
  @_Concurrency.MainActor(unsafe) public var uiParams: AuthMeUI.AuthMeLivenessUIParams?
  @_Concurrency.MainActor(unsafe) public var isInfoPageEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public let action: AuthMe.Action
  @_Concurrency.MainActor(unsafe) public var eventTrackingEnable: Swift.Bool
  @_Concurrency.MainActor(unsafe) public init(action: AuthMe.Action = .register(waitResult: true))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
}
public protocol AnimationImageProvider {
  var cacheEligible: Swift.Bool { get }
  func imageForAsset(asset: AuthMeUI.ImageAsset) -> CoreGraphics.CGImage?
  func contentsGravity(for asset: AuthMeUI.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
extension AuthMeUI.AnimationImageProvider {
  public var cacheEligible: Swift.Bool {
    get
  }
  public func contentsGravity(for _: AuthMeUI.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension AuthMeUI.Asset : @unchecked Swift.Sendable {
}
public struct LottieSwitch {
  public init(animation: AuthMeUI.LottieAnimation?)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public func configure(_ configure: @escaping (AuthMeUI.AnimatedSwitch) -> Swift.Void) -> AuthMeUI.LottieSwitch
  public func configuration(_ configuration: AuthMeUI.LottieConfiguration) -> AuthMeUI.LottieSwitch
  public func isOn(_ binding: SwiftUI.Binding<Swift.Bool>) -> AuthMeUI.LottieSwitch
  public func onAnimation(fromProgress onStartProgress: AuthMeUI.AnimationProgressTime, toProgress onEndProgress: AuthMeUI.AnimationProgressTime) -> AuthMeUI.LottieSwitch
  public func offAnimation(fromProgress offStartProgress: AuthMeUI.AnimationProgressTime, toProgress offEndProgress: AuthMeUI.AnimationProgressTime) -> AuthMeUI.LottieSwitch
  public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: AuthMeUI.AnimationKeypath) -> AuthMeUI.LottieSwitch where ValueProvider : AuthMeUI.AnyValueProvider, ValueProvider : Swift.Equatable
  public typealias Body = @_opaqueReturnTypeOf("$s8AuthMeUI12LottieSwitchV4bodyQrvp", 0) __
}
@available(*, deprecated, message: "Use DefaultAnimationCache instead, which is thread-safe and automatically responds to memory pressure.")
public typealias LRUAnimationCache = AuthMeUI.DefaultAnimationCache
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : AuthMeUI.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension AuthMeUI.DefaultFontProvider : Swift.Equatable {
  public static func == (_: AuthMeUI.DefaultFontProvider, _: AuthMeUI.DefaultFontProvider) -> Swift.Bool
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedButton : AuthMeUI.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: AuthMeUI.LottieAnimation?, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) public var performAction: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromProgress: AuthMeUI.AnimationProgressTime, toProgress: AuthMeUI.AnimationProgressTime, event: AuthMeUI.LottieControlEvent)
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: AuthMeUI.LottieControlEvent)
  @objc deinit
}
public enum DecodingStrategy : Swift.Hashable {
  case legacyCodable
  case dictionaryBased
  public static func == (a: AuthMeUI.DecodingStrategy, b: AuthMeUI.DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Keyframe<T> {
  public init(_ value: T, spatialInTangent: AuthMeUI.LottieVector3D? = nil, spatialOutTangent: AuthMeUI.LottieVector3D? = nil)
  public init(value: T, time: AuthMeUI.AnimationFrameTime, isHold: Swift.Bool = false, inTangent: AuthMeUI.LottieVector2D? = nil, outTangent: AuthMeUI.LottieVector2D? = nil, spatialInTangent: AuthMeUI.LottieVector3D? = nil, spatialOutTangent: AuthMeUI.LottieVector3D? = nil)
  final public let value: T
  final public let time: AuthMeUI.AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: AuthMeUI.LottieVector2D?
  final public let outTangent: AuthMeUI.LottieVector2D?
  final public let spatialInTangent: AuthMeUI.LottieVector3D?
  final public let spatialOutTangent: AuthMeUI.LottieVector3D?
  @objc deinit
}
extension AuthMeUI.Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: AuthMeUI.Keyframe<T>, rhs: AuthMeUI.Keyframe<T>) -> Swift.Bool
}
extension AuthMeUI.Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension AuthMeUI.Keyframe : Swift.Sendable where T : Swift.Sendable {
}
extension AuthMeUI.LottieAnimation {
  public typealias DownloadClosure = (AuthMeUI.LottieAnimation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared) -> AuthMeUI.LottieAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared) -> AuthMeUI.LottieAnimation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared) -> AuthMeUI.LottieAnimation?
  public static func from(data: Foundation.Data, strategy: AuthMeUI.DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> AuthMeUI.LottieAnimation
  #if compiler(>=5.3) && $AsyncAwait
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared) async -> AuthMeUI.LottieAnimation?
  #endif
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping AuthMeUI.LottieAnimation.DownloadClosure, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared)
  final public func progressTime(forMarker named: Swift.String) -> AuthMeUI.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: AuthMeUI.AnimationFrameTime, clamped: Swift.Bool = true) -> AuthMeUI.AnimationProgressTime
  final public func frameTime(forProgress progressTime: AuthMeUI.AnimationProgressTime) -> AuthMeUI.AnimationFrameTime
  final public func time(forFrame frameTime: AuthMeUI.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> AuthMeUI.AnimationFrameTime
}
extension Foundation.Bundle : @unchecked Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedSwitch : AuthMeUI.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: AuthMeUI.LottieAnimation?, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) override open func animationDidSet()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: AuthMeUI.AnimatedSwitch.CancelBehavior, b: AuthMeUI.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var cancelBehavior: AuthMeUI.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor(unsafe) public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var stateUpdated: ((_ isOn: Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func setProgressForState(fromProgress: AuthMeUI.AnimationProgressTime, toProgress: AuthMeUI.AnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
public struct LottieVector1D : Swift.Hashable, Swift.Sendable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottieVector1D, b: AuthMeUI.LottieVector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieVector3D : Swift.Hashable, Swift.Sendable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottieVector3D, b: AuthMeUI.LottieVector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AuthmeMenuCellable : UIKit.UIView {
  var titleLabel: UIKit.UILabel { get set }
  var isSelected: Swift.Bool { get set }
}
final public class SizeValueProvider {
  public init(block: @escaping AuthMeUI.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: AuthMeUI.ValueProviderStorage<AuthMeUI.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension AuthMeUI.SizeValueProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.SizeValueProvider, rhs: AuthMeUI.SizeValueProvider) -> Swift.Bool
}
extension AuthMeUI.LottieVector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct LottieVector2D : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: AuthMeUI.LottieVector2D, b: AuthMeUI.LottieVector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension AuthMeUI.LottieVector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension AuthMeUI.LottieVector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public enum ReducedMotionOption {
  case specific(AuthMeUI.ReducedMotionMode)
  case dynamic(any AuthMeUI.ReducedMotionOptionProvider, dataID: Swift.AnyHashable)
}
extension AuthMeUI.ReducedMotionOption {
  public static var standardMotion: AuthMeUI.ReducedMotionOption {
    get
  }
  public static var reducedMotion: AuthMeUI.ReducedMotionOption {
    get
  }
  public static var systemReducedMotionToggle: AuthMeUI.ReducedMotionOption {
    get
  }
}
extension AuthMeUI.ReducedMotionOption {
  public var currentReducedMotionMode: AuthMeUI.ReducedMotionMode {
    get
  }
}
extension AuthMeUI.ReducedMotionOption : Swift.Hashable {
  public static func == (lhs: AuthMeUI.ReducedMotionOption, rhs: AuthMeUI.ReducedMotionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ReducedMotionMode : Swift.Hashable {
  case standardMotion
  case reducedMotion
  public static func == (a: AuthMeUI.ReducedMotionMode, b: AuthMeUI.ReducedMotionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ReducedMotionOptionProvider {
  var currentReducedMotionMode: AuthMeUI.ReducedMotionMode { get }
}
public struct SystemReducedMotionOptionProvider : AuthMeUI.ReducedMotionOptionProvider {
  public init()
  public var currentReducedMotionMode: AuthMeUI.ReducedMotionMode {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : AuthMeUI.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public protocol Interpolatable : AuthMeUI.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : AuthMeUI.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol AnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension AuthMeUI.Interpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension AuthMeUI.SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : AuthMeUI.Interpolatable {
}
extension CoreFoundation.CGFloat : AuthMeUI.Interpolatable {
}
extension Swift.Float : AuthMeUI.Interpolatable {
}
extension AuthMeUI.Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : AuthMeUI.Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : AuthMeUI.Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : AuthMeUI.SpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension AuthMeUI.LottieColor : AuthMeUI.Interpolatable {
  public func interpolate(to: AuthMeUI.LottieColor, amount: CoreFoundation.CGFloat) -> AuthMeUI.LottieColor
}
extension AuthMeUI.LottieVector1D : AuthMeUI.Interpolatable {
  public func interpolate(to: AuthMeUI.LottieVector1D, amount: CoreFoundation.CGFloat) -> AuthMeUI.LottieVector1D
}
extension AuthMeUI.LottieVector2D : AuthMeUI.SpatialInterpolatable {
  public func interpolate(to: AuthMeUI.LottieVector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> AuthMeUI.LottieVector2D
}
extension AuthMeUI.LottieVector3D : AuthMeUI.SpatialInterpolatable {
  public func interpolate(to: AuthMeUI.LottieVector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> AuthMeUI.LottieVector3D
}
extension Swift.Array : AuthMeUI.Interpolatable, AuthMeUI.AnyInterpolatable where Element : AuthMeUI.Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
extension Swift.Optional : AuthMeUI.Interpolatable, AuthMeUI.AnyInterpolatable where Wrapped : AuthMeUI.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
final public class GradientValueProvider {
  public init(block: @escaping AuthMeUI.GradientValueProvider.ColorsValueBlock, locations: AuthMeUI.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [AuthMeUI.LottieColor], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [AuthMeUI.LottieColor]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [AuthMeUI.LottieColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: AuthMeUI.ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension AuthMeUI.GradientValueProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.GradientValueProvider, rhs: AuthMeUI.GradientValueProvider) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class AuthMeOCRUIParams {
  public static func setWith(block: (AuthMeUI.AuthMeOCRUIParams) -> Swift.Void) -> AuthMeUI.AuthMeOCRUIParams
  @objc deinit
}
extension AuthMeUI.AuthMeOCRUIParams {
  @discardableResult
  final public func isColseButtonHidden(_ isHidden: Swift.Bool) -> Self
}
@_hasMissingDesignatedInitializers final public class AuthmeFeatureConfig {
  public static func setWith(_ block: (AuthMeUI.AuthmeFeatureConfig) -> Swift.Void) -> AuthMeUI.AuthmeFeatureConfig
  @objc deinit
}
extension AuthMeUI.AuthmeFeatureConfig {
  @discardableResult
  final public func needConfirm(_ needConfirm: Swift.Bool) -> Self
  @discardableResult
  final public func waterMark(_ waterMark: UIKit.UIImage) -> Self
  @discardableResult
  final public func isResultPageDisplayable(_ isResultPageDisplayable: Swift.Bool) -> Self
  @discardableResult
  final public func isResultEditable(_ isResultEditable: Swift.Bool) -> Self
  @discardableResult
  final public func isEventTrackingEnable(_ isEventTrackingEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isFraudIntroEnable(_ isFraudIntroEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isFraudHintAnimationEnable(_ isFraudHintAnimationEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isNFCOffline(_ isNFCOffline: Swift.Bool) -> Self
}
@objc @_hasMissingDesignatedInitializers public class LottieAnimationLayer : QuartzCore.CALayer {
  public init(animation: AuthMeUI.LottieAnimation?, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, textProvider: any AuthMeUI.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any AuthMeUI.AnimationFontProvider = DefaultFontProvider(), configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  public init(dotLottie: AuthMeUI.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any AuthMeUI.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any AuthMeUI.AnimationFontProvider = DefaultFontProvider(), configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  public init(configuration: AuthMeUI.LottieConfiguration = .shared, logger: AuthMeUI.LottieLogger = .shared)
  open func play(completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(fromProgress: AuthMeUI.AnimationProgressTime? = nil, toProgress: AuthMeUI.AnimationProgressTime, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(fromFrame: AuthMeUI.AnimationFrameTime? = nil, toFrame: AuthMeUI.AnimationFrameTime, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(marker: Swift.String, loopMode: AuthMeUI.LottieLoopMode? = nil, completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(markers: [Swift.String], completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func stop()
  open func pause()
  open func pause(at state: AuthMeUI.LottiePlaybackMode.PausedState)
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  open func play(_ playbackMode: AuthMeUI.LottiePlaybackMode, animationCompletionHandler: AuthMeUI.LottieCompletionBlock? = nil)
  open func setPlaybackMode(_ playbackMode: AuthMeUI.LottiePlaybackMode, completion: AuthMeUI.LottieCompletionBlock? = nil)
  open func play(_ playbackMode: AuthMeUI.LottiePlaybackMode.PlaybackMode, completion: AuthMeUI.LottieCompletionBlock? = nil)
  public var currentPlaybackMode: AuthMeUI.LottiePlaybackMode? {
    get
  }
  public var valueProviders: [AuthMeUI.AnimationKeypath : any AuthMeUI.AnyValueProvider] {
    get
  }
  public var animationLayerDidLoad: ((_ animationLayer: AuthMeUI.LottieAnimationLayer, _ renderingEngine: AuthMeUI.RenderingEngineOption) -> Swift.Void)?
  public var configuration: AuthMeUI.LottieConfiguration {
    get
    set
  }
  public var animationLayer: QuartzCore.CALayer? {
    get
  }
  public var screenScale: CoreFoundation.CGFloat {
    get
    set
  }
  public var backgroundBehavior: AuthMeUI.LottieBackgroundBehavior {
    get
    set
  }
  public var animation: AuthMeUI.LottieAnimation? {
    get
    set
  }
  public var animationLoaded: ((_ animationLayer: AuthMeUI.LottieAnimationLayer, _ animation: AuthMeUI.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  public var imageProvider: any AuthMeUI.AnimationImageProvider {
    get
    set
  }
  public var textProvider: any AuthMeUI.AnimationKeypathTextProvider {
    get
    set
  }
  public var fontProvider: any AuthMeUI.AnimationFontProvider {
    get
    set
  }
  public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  public var isAnimationPlaying: Swift.Bool {
    get
  }
  public var loopMode: AuthMeUI.LottieLoopMode {
    get
    set
  }
  public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  public var currentProgress: AuthMeUI.AnimationProgressTime {
    get
    set
  }
  public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  public var currentFrame: AuthMeUI.AnimationFrameTime {
    get
    set
  }
  public var realtimeAnimationFrame: AuthMeUI.AnimationFrameTime {
    get
  }
  public var realtimeAnimationProgress: AuthMeUI.AnimationProgressTime {
    get
  }
  public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  public var currentRenderingEngine: AuthMeUI.RenderingEngine? {
    get
  }
  public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: AuthMeUI.DotLottieFile)
  public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: AuthMeUI.DotLottieFile)
  public func reloadImages()
  public func forceDisplayUpdate()
  public func setValueProvider(_ valueProvider: any AuthMeUI.AnyValueProvider, keypath: AuthMeUI.AnimationKeypath)
  public func getValue(for keypath: AuthMeUI.AnimationKeypath, atFrame: AuthMeUI.AnimationFrameTime?) -> Any?
  public func getOriginalValue(for keypath: AuthMeUI.AnimationKeypath, atFrame: AuthMeUI.AnimationFrameTime?) -> Any?
  public func logHierarchyKeypaths()
  public func allHierarchyKeypaths() -> [Swift.String]
  public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: AuthMeUI.AnimationKeypath?) -> CoreFoundation.CGRect?
  public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: AuthMeUI.AnimationKeypath?) -> CoreFoundation.CGPoint?
  public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: AuthMeUI.AnimationKeypath)
  public func progressTime(forMarker named: Swift.String) -> AuthMeUI.AnimationProgressTime?
  public func frameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  public func durationFrameTime(forMarker named: Swift.String) -> AuthMeUI.AnimationFrameTime?
  public func updateAnimationForBackgroundState()
  public func updateAnimationForForegroundState(wasWaitingToPlayAnimation: Swift.Bool)
  @objc deinit
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: AuthMeUI.AnimationKeypath
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class LivenessPlaygroundViewController : AuthMeUI.BaseViewController, AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any AuthMeUI.AuthMePlaygroundDelegate)?
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)? = nil, handler: ((Swift.Result<Swift.Void, AuthMe.FlowError>) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
}
extension AuthMeUI.LivenessPlaygroundViewController : AVFoundation.AVCaptureDataOutputSynchronizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func dataOutputSynchronizer(_ synchronizer: AVFoundation.AVCaptureDataOutputSynchronizer, didOutput synchronizedDataCollection: AVFoundation.AVCaptureSynchronizedDataCollection)
}
extension AuthMeUI.LivenessPlaygroundViewController : AuthMe.LivenessPlaygroundFlowDelegate {
  @_Concurrency.MainActor(unsafe) public func livenessDidStart()
  @_Concurrency.MainActor(unsafe) public func livenessDidNotifyMessage(status: AuthMe.LivenessDetectStatus)
  @_Concurrency.MainActor(unsafe) public func livenessDidUpdateReconize(result: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func livenessDidFailureWith(error: AuthMe.FlowError, retryHandler: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor(unsafe) public func livenessDidRecognize(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func livenessQueueDidUpload(currentCount: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func livenessDidFaceScale(direction: AuthMe.LivenessFlow.FaceScaleDirection.Direction)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyStage(log: AuthMe.LogFAS)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyUpload(log: AuthMe.LogUpload)
}
extension AuthMeUI.LivenessPlaygroundViewController {
  public enum LivenessResult {
    case succeed(UIKit.UIImage)
    case failed
    case canceled
  }
}
public typealias LottieCompletionBlock = (_ completed: Swift.Bool) -> Swift.Void
public enum TransitionStyle {
  case push
  case present
  public static func == (a: AuthMeUI.TransitionStyle, b: AuthMeUI.TransitionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FlowControl {
  public var isMenuEnabled: Swift.Bool
  public var authFlow: [AuthMeUI.AuthmeFeature]
  public init(isMenuEnabled: Swift.Bool, authFlow: [AuthMeUI.AuthmeFeature])
}
public protocol AuthmeCoordinatorDelegate : AnyObject {
  func coordinatorDidFinishScan()
}
public protocol AuthmeCoordinatorDataSource : AnyObject {
  func flow(accessTokenFor feature: AuthMeUI.AuthmeFeature, completion: ((Swift.String) -> Swift.Void)?)
  func flow(featureConfigFor feature: AuthMeUI.AuthmeFeature) -> AuthMeUI.AuthmeFeatureConfig
}
final public class AuthmeCoordinator {
  @objc deinit
  weak final public var authDelegate: (any AuthMeUI.AuthMeAuthenticationDelegate)?
  weak final public var delegate: (any AuthMeUI.AuthmeCoordinatorDelegate)?
  weak final public var dataSource: (any AuthMeUI.AuthmeCoordinatorDataSource)?
  public init(presenter: UIKit.UIViewController, flowControl: AuthMeUI.FlowControl)
  final public func start(with transitionStyle: AuthMeUI.TransitionStyle, animated: Swift.Bool)
}
public typealias LottieControlType = UIKit.UIControl
public typealias LottieControlState = UIKit.UIControl.State
public typealias LottieControlEvent = UIKit.UIControl.Event
final public class PointValueProvider {
  public init(block: @escaping AuthMeUI.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: AuthMeUI.ValueProviderStorage<AuthMeUI.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension AuthMeUI.PointValueProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.PointValueProvider, rhs: AuthMeUI.PointValueProvider) -> Swift.Bool
}
public enum LottieAnimationCache {
  public static var shared: (any AuthMeUI.AnimationCacheProvider)?
}
public struct LottieView<Placeholder> where Placeholder : SwiftUI.View {
  public init(animation: AuthMeUI.LottieAnimation?) where Placeholder == SwiftUI.EmptyView
  public init(dotLottieFile: AuthMeUI.DotLottieFile?) where Placeholder == SwiftUI.EmptyView
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadAnimation: @escaping () async throws -> AuthMeUI.LottieAnimation?) where Placeholder == SwiftUI.EmptyView
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadAnimation: @escaping () async throws -> AuthMeUI.LottieAnimation?, @SwiftUI.ViewBuilder placeholder: @escaping (() -> Placeholder))
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadDotLottieFile: @escaping () async throws -> AuthMeUI.DotLottieFile?) where Placeholder == SwiftUI.EmptyView
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadDotLottieFile: @escaping () async throws -> AuthMeUI.DotLottieFile?, @SwiftUI.ViewBuilder placeholder: @escaping (() -> Placeholder))
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadAnimation: @escaping () async throws -> AuthMeUI.LottieAnimationSource?) where Placeholder == SwiftUI.EmptyView
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public init(_ loadAnimation: @escaping () async throws -> AuthMeUI.LottieAnimationSource?, @SwiftUI.ViewBuilder placeholder: @escaping () -> Placeholder)
  #endif
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<AuthMeUI.LottieAnimationView, Property>, to value: Property) -> AuthMeUI.LottieView<Placeholder>
  public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<AuthMeUI.LottieAnimationView, Property>, to value: Property) -> AuthMeUI.LottieView<Placeholder> where Property : Swift.Equatable
  public func configure(_ configure: @escaping (AuthMeUI.LottieAnimationView) -> Swift.Void) -> AuthMeUI.LottieView<Placeholder>
  public func resizable() -> AuthMeUI.LottieView<Placeholder>
  public func intrinsicSize() -> AuthMeUI.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing()", message: "Will be removed in a future major release.")
  public func play() -> AuthMeUI.LottieView<Placeholder>
  public func looping() -> AuthMeUI.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing(_:)", message: "Will be removed in a future major release.")
  public func play(loopMode: AuthMeUI.LottieLoopMode = .playOnce) -> AuthMeUI.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playbackMode(_:)", message: "Will be removed in a future major release.")
  public func play(_ playbackMode: AuthMeUI.LottiePlaybackMode) -> AuthMeUI.LottieView<Placeholder>
  public func playing(_ mode: AuthMeUI.LottiePlaybackMode.PlaybackMode) -> AuthMeUI.LottieView<Placeholder>
  public func playing(loopMode: AuthMeUI.LottieLoopMode) -> AuthMeUI.LottieView<Placeholder>
  public func playing() -> AuthMeUI.LottieView<Placeholder>
  public func paused(at state: AuthMeUI.LottiePlaybackMode.PausedState = .currentFrame) -> AuthMeUI.LottieView<Placeholder>
  public func playbackMode(_ playbackMode: AuthMeUI.LottiePlaybackMode) -> AuthMeUI.LottieView<Placeholder>
  public func animationSpeed(_ animationSpeed: Swift.Double) -> AuthMeUI.LottieView<Placeholder>
  public func animationDidLoad(_ animationDidLoad: @escaping (AuthMeUI.LottieAnimationSource) -> Swift.Void) -> AuthMeUI.LottieView<Placeholder>
  public func animationDidFinish(_ animationCompletionHandler: AuthMeUI.LottieCompletionBlock?) -> AuthMeUI.LottieView<Placeholder>
  public func backgroundBehavior(_ value: AuthMeUI.LottieBackgroundBehavior) -> AuthMeUI.LottieView<Placeholder>
  public func accessibilityLabel(_ accessibilityLabel: Swift.String?) -> AuthMeUI.LottieView<Placeholder>
  public func configuration(_ configuration: AuthMeUI.LottieConfiguration) -> AuthMeUI.LottieView<Placeholder>
  public func logger(_ logger: AuthMeUI.LottieLogger) -> AuthMeUI.LottieView<Placeholder>
  public func imageProvider<ImageProvider>(_ imageProvider: ImageProvider) -> AuthMeUI.LottieView<Placeholder> where ImageProvider : AuthMeUI.AnimationImageProvider, ImageProvider : Swift.Equatable
  public func textProvider<TextProvider>(_ textProvider: TextProvider) -> AuthMeUI.LottieView<Placeholder> where TextProvider : AuthMeUI.AnimationKeypathTextProvider, TextProvider : Swift.Equatable
  public func fontProvider<FontProvider>(_ fontProvider: FontProvider) -> AuthMeUI.LottieView<Placeholder> where FontProvider : AuthMeUI.AnimationFontProvider, FontProvider : Swift.Equatable
  public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: AuthMeUI.AnimationKeypath) -> AuthMeUI.LottieView<Placeholder> where ValueProvider : AuthMeUI.AnyValueProvider, ValueProvider : Swift.Equatable
  public func currentProgress(_ currentProgress: AuthMeUI.AnimationProgressTime?) -> AuthMeUI.LottieView<Placeholder>
  public func currentFrame(_ currentFrame: AuthMeUI.AnimationFrameTime?) -> AuthMeUI.LottieView<Placeholder>
  public func currentTime(_ currentTime: Foundation.TimeInterval?) -> AuthMeUI.LottieView<Placeholder>
  public func reloadAnimationTrigger(_ value: some Equatable, showPlaceholder: Swift.Bool = true) -> AuthMeUI.LottieView<Placeholder>
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  public func getRealtimeAnimationProgress(_ realtimeAnimationProgress: SwiftUI.Binding<AuthMeUI.AnimationProgressTime>?) -> some SwiftUI.View
  
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  public func getRealtimeAnimationFrame(_ realtimeAnimationFrame: SwiftUI.Binding<AuthMeUI.AnimationFrameTime>?) -> some SwiftUI.View
  
  public func dotLottieConfigurationComponents(_ dotLottieConfigurationComponents: AuthMeUI.DotLottieConfigurationComponents) -> AuthMeUI.LottieView<Placeholder>
  public typealias Body = @_opaqueReturnTypeOf("$s8AuthMeUI10LottieViewV4bodyQrvp", 0) __<Placeholder>
}
public class DotLottieCache : AuthMeUI.DotLottieCacheProvider {
  public init()
  public static let sharedCache: AuthMeUI.DotLottieCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func file(forKey key: Swift.String) -> AuthMeUI.DotLottieFile?
  public func setFile(_ lottie: AuthMeUI.DotLottieFile, forKey key: Swift.String)
  @objc deinit
}
extension AuthMeUI.DotLottieCache : @unchecked Swift.Sendable {
}
public protocol DotLottieCacheProvider : Swift.Sendable {
  func file(forKey: Swift.String) -> AuthMeUI.DotLottieFile?
  func setFile(_ lottie: AuthMeUI.DotLottieFile, forKey: Swift.String)
  func clearCache()
}
public enum NFCDeviceError : Swift.String, Swift.Error {
  case NotSupport
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension AuthMeUI.LottieAnimationView {
  @_Concurrency.MainActor(unsafe) convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(filePath: Swift.String, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(url: Foundation.URL, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, session: Foundation.URLSession = .shared, closure: @escaping AuthMeUI.LottieAnimationView.DownloadClosure, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any AuthMeUI.AnimationImageProvider)? = nil, animationCache: (any AuthMeUI.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(dotLottieName name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationId: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: AuthMeUI.LottieConfiguration = .shared, completion: ((AuthMeUI.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(dotLottieFilePath filePath: Swift.String, animationId: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: AuthMeUI.LottieConfiguration = .shared, completion: ((AuthMeUI.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(dotLottieUrl url: Foundation.URL, animationId: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: AuthMeUI.LottieConfiguration = .shared, session: Foundation.URLSession = .shared, completion: ((AuthMeUI.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(dotLottieAsset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationId: Swift.String? = nil, dotLottieCache: (any AuthMeUI.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: AuthMeUI.LottieConfiguration = .shared, completion: ((AuthMeUI.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public struct AuthMeUIConfig {
  public struct Customized {
    public struct ActionButton {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct ActionHint {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct CloseHint {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct BackHint {
      public let contentColor: UIKit.UIColor
      public init(contentColor: UIKit.UIColor)
    }
    public struct Scanner {
      public let contentColor: UIKit.UIColor
      public init(contentColor: UIKit.UIColor)
    }
    public struct StepButton {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public let actionButton: AuthMeUI.AuthMeUIConfig.Customized.ActionButton
    public let actionHint: AuthMeUI.AuthMeUIConfig.Customized.ActionHint
    public let closeHint: AuthMeUI.AuthMeUIConfig.Customized.CloseHint
    public let backHint: AuthMeUI.AuthMeUIConfig.Customized.BackHint
    public let scanner: AuthMeUI.AuthMeUIConfig.Customized.Scanner
    public let stepButton: AuthMeUI.AuthMeUIConfig.Customized.StepButton
    public let isConfirmImageShown: Swift.Bool
    public init(actionButton: AuthMeUI.AuthMeUIConfig.Customized.ActionButton, actionHint: AuthMeUI.AuthMeUIConfig.Customized.ActionHint, closeHint: AuthMeUI.AuthMeUIConfig.Customized.CloseHint, backHint: AuthMeUI.AuthMeUIConfig.Customized.BackHint, scanner: AuthMeUI.AuthMeUIConfig.Customized.Scanner, stepButton: AuthMeUI.AuthMeUIConfig.Customized.StepButton, isConfirmImageShown: Swift.Bool)
  }
  public var customized: AuthMeUI.AuthMeUIConfig.Customized
  public var showStatement: Swift.Bool
  public var isScreenRatioEnabled: Swift.Bool
  public init(customized: AuthMeUI.AuthMeUIConfig.Customized, showStatement: Swift.Bool)
}
@_hasMissingDesignatedInitializers final public class AuthMeLivenessUIParams {
  public static func setWith(block: (AuthMeUI.AuthMeLivenessUIParams) -> Swift.Void) -> AuthMeUI.AuthMeLivenessUIParams
  @objc deinit
}
extension AuthMeUI.AuthMeLivenessUIParams {
  @discardableResult
  final public func isColseButtonHidden(_ isHidden: Swift.Bool) -> Self
}
@_hasMissingDesignatedInitializers final public class AuthmeKYCConfig {
  public static func setWith(block: (AuthMeUI.AuthmeKYCConfig) -> Swift.Void) -> AuthMeUI.AuthmeKYCConfig
  @objc deinit
}
extension AuthMeUI.AuthmeKYCConfig {
  @discardableResult
  final public func isUploadFullFrameEnabaled(_ enabled: Swift.Bool) -> Self
}
@objc @_Concurrency.MainActor(unsafe) open class AnimatedControl : AuthMeUI.LottieControlType {
  @_Concurrency.MainActor(unsafe) public init(animation: AuthMeUI.LottieAnimation?, configuration: AuthMeUI.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) open func animationDidSet()
  @_Concurrency.MainActor(unsafe) final public let animationView: AuthMeUI.LottieAnimationView
  @_Concurrency.MainActor(unsafe) public var animation: AuthMeUI.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setLayer(named: Swift.String, forState: AuthMeUI.LottieControlState)
  @_Concurrency.MainActor(unsafe) public func setValueProvider(_ valueProvider: any AuthMeUI.AnyValueProvider, keypath: AuthMeUI.AnimationKeypath)
  @objc deinit
}
final public class FloatValueProvider {
  public init(block: @escaping AuthMeUI.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: AuthMeUI.ValueProviderStorage<AuthMeUI.LottieVector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension AuthMeUI.FloatValueProvider : Swift.Equatable {
  public static func == (lhs: AuthMeUI.FloatValueProvider, rhs: AuthMeUI.FloatValueProvider) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension AuthMeUI.AuthMeUICoordinator where T == AuthMe.OfflineMode {
  final public func start(with transitionStyle: AuthMeUI.TransitionStyle, animated: Swift.Bool)
}
@_hasMissingDesignatedInitializers final public class DotLottieFile {
  public struct Animation {
    public let animation: AuthMeUI.LottieAnimation
    public let configuration: AuthMeUI.DotLottieConfiguration
  }
  final public var animations: [AuthMeUI.DotLottieFile.Animation] {
    get
  }
  @objc deinit
}
extension AuthMeUI.DotLottieFile : @unchecked Swift.Sendable {
}
public enum DotLottieError : Swift.Error {
  case noDataLoaded
  case assetNotFound(name: Swift.String, bundle: Foundation.Bundle?)
  case loadingFromAssetNotSupported
  @available(*, deprecated, message: "Unused")
  case invalidFileFormat
  @available(*, deprecated, message: "Unused")
  case invalidData
  @available(*, deprecated, message: "Unused")
  case animationNotAvailable
}
public enum LottieAnimationSource : Swift.Sendable {
  case lottieAnimation(AuthMeUI.LottieAnimation)
  case dotLottieFile(AuthMeUI.DotLottieFile)
}
extension AuthMeUI.LottieAnimation {
  final public var animationSource: AuthMeUI.LottieAnimationSource {
    get
  }
}
extension AuthMeUI.DotLottieFile {
  final public var animationSource: AuthMeUI.LottieAnimationSource {
    get
  }
}
extension AuthMeUI.LottieBackgroundBehavior : Swift.Equatable {}
extension AuthMeUI.LottieBackgroundBehavior : Swift.Hashable {}
extension AuthMeUI.CoordinateSpace : Swift.Equatable {}
extension AuthMeUI.CoordinateSpace : Swift.Hashable {}
extension AuthMeUI.CoordinateSpace : Swift.RawRepresentable {}
extension AuthMeUI.CompatibleRenderingEngineOption : Swift.Equatable {}
extension AuthMeUI.CompatibleRenderingEngineOption : Swift.Hashable {}
extension AuthMeUI.CompatibleRenderingEngineOption : Swift.RawRepresentable {}
extension AuthMeUI.CompatibleBackgroundBehavior : Swift.Equatable {}
extension AuthMeUI.CompatibleBackgroundBehavior : Swift.Hashable {}
extension AuthMeUI.CompatibleBackgroundBehavior : Swift.RawRepresentable {}
extension AuthMeUI.AuthMeLocalize : Swift.Equatable {}
extension AuthMeUI.AuthMeLocalize : Swift.Hashable {}
extension AuthMeUI.AuthMeLocalize : Swift.RawRepresentable {}
extension AuthMeUI.ColorValueProvider : AuthMeUI.AnyValueProvider {}
extension AuthMeUI.AuthmeFeature : Swift.Equatable {}
extension AuthMeUI.AuthmeFeature : Swift.Hashable {}
extension AuthMeUI.AuthmeFeature : Swift.RawRepresentable {}
extension AuthMeUI.AuthMeLivenessViewController.`Type` : Swift.Equatable {}
extension AuthMeUI.AuthMeLivenessViewController.`Type` : Swift.Hashable {}
extension AuthMeUI.LottieButton : SwiftUI.View {}
extension AuthMeUI.LottieSwitch : SwiftUI.View {}
extension AuthMeUI.LayerType : Swift.Equatable {}
extension AuthMeUI.LayerType : Swift.Hashable {}
extension AuthMeUI.LayerType : Swift.RawRepresentable {}
extension AuthMeUI.MatteType : Swift.Equatable {}
extension AuthMeUI.MatteType : Swift.Hashable {}
extension AuthMeUI.MatteType : Swift.RawRepresentable {}
extension AuthMeUI.BlendMode : Swift.Equatable {}
extension AuthMeUI.BlendMode : Swift.Hashable {}
extension AuthMeUI.BlendMode : Swift.RawRepresentable {}
extension AuthMeUI.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension AuthMeUI.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension AuthMeUI.SizeValueProvider : AuthMeUI.AnyValueProvider {}
extension AuthMeUI.GradientValueProvider : AuthMeUI.AnyValueProvider {}
extension AuthMeUI.TransitionStyle : Swift.Equatable {}
extension AuthMeUI.TransitionStyle : Swift.Hashable {}
extension AuthMeUI.PointValueProvider : AuthMeUI.AnyValueProvider {}
extension AuthMeUI.LottieView : SwiftUI.View {}
extension AuthMeUI.NFCDeviceError : Swift.Equatable {}
extension AuthMeUI.NFCDeviceError : Swift.Hashable {}
extension AuthMeUI.NFCDeviceError : Swift.RawRepresentable {}
extension AuthMeUI.FloatValueProvider : AuthMeUI.AnyValueProvider {}
