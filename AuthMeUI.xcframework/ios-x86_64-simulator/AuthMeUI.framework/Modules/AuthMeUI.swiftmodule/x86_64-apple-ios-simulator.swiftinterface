// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AuthMeUI
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AudioToolbox
import AuthMe
@_exported import AuthMeUI
import CommonCrypto
import CoreGraphics/*.CGFloat*/
import CoreMotion
import CoreNFC
import CryptoKit
import CryptoTokenKit
import DeveloperToolsSupport
import Foundation
import ImageIO
import OpenSSL
import QuartzCore
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public class AuthMeAccessToken {
  public init(tokenURL: Foundation.URL, client: Swift.String, secret: Swift.String, customerID: Swift.String)
  public struct Response : Swift.Decodable {
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Error : Swift.Error {
    case invalidStatusCode(Swift.Int?, Foundation.Data?)
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class BaseViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup7 : AuthMeUI.DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class NotImplementedDG : AuthMeUI.DataGroup {
  @objc deinit
}
public protocol AuthMeAuthenticationDelegate : ObjectiveC.NSObjectProtocol {
  func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  func authmeLivenessViewController(didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didFinishVerifyWith result: AuthMeUI.AuthMeLivenessViewController.LivenessResult, isVerifyPass: Swift.Bool)
  func authTWIDFraudResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWIDResult?, error: (any Swift.Error)?)
  func authTWIDResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWIDResult?, error: (any Swift.Error)?)
  func authTWLicenseResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWLicenseResult?, error: (any Swift.Error)?)
  func authTWHealthResult(image: UIKit.UIImage?, result: TWHealthResult?, error: (any Swift.Error)?)
  func authMRZResult(result: MRZResult?, error: (any Swift.Error)?)
  func authTWNResident(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWNResidentResult?, error: (any Swift.Error)?)
  func authJPNIDCard(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: JPNIDCardResult?, error: (any Swift.Error)?)
  func authJPNIDCardNFC(_ result: JPNIDCardNFCResult?, error: (any Swift.Error)?)
  func authJPNDriverLicense(image: UIKit.UIImage?, result: JPNDriverLicenseResult?, error: (any Swift.Error)?)
  func authJPNResidentCard(image: UIKit.UIImage?, result: JPNResidentCardResult?, error: (any Swift.Error)?)
  func authUSAIDCard(image: UIKit.UIImage?, result: USAIDCardResult?, error: (any Swift.Error)?)
  func authUSADriverLicense(image: UIKit.UIImage?, result: USADriverLicenseResult?, error: (any Swift.Error)?)
  func authUSAVisitorVISA(image: UIKit.UIImage?, result: USAVisitorVISAResult?, error: (any Swift.Error)?)
  func authIDNIDCard(image: UIKit.UIImage?, result: IDNIDCardResult?, error: (any Swift.Error)?)
  func authIDNDriverLicense(image: UIKit.UIImage?, result: IDNDriverLicenseResult?, error: (any Swift.Error)?)
  func personalPrivacyResult(result: Swift.Bool)
  func authenticateCompleted()
}
extension AuthMeUI.AuthMeAuthenticationDelegate {
  public func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  public func authmeLivenessViewController(didRecognize result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
  public func authmeLivenessViewController(_ viewController: AuthMeUI.AuthMeLivenessViewController, didFinishVerifyWith result: AuthMeUI.AuthMeLivenessViewController.LivenessResult, isVerifyPass: Swift.Bool)
  public func authTWIDFraudResult(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWIDResult?, error: (any Swift.Error)?)
  public func authTWIDResult(frontImage _: UIKit.UIImage?, backImage _: UIKit.UIImage?, result _: TWIDResult?, error _: (any Swift.Error)?)
  public func authTWLicenseResult(frontImage _: UIKit.UIImage?, backImage _: UIKit.UIImage?, result _: TWLicenseResult?, error _: (any Swift.Error)?)
  public func authTWHealthResult(image _: UIKit.UIImage?, result _: TWHealthResult?, error _: (any Swift.Error)?)
  public func authMRZResult(result _: MRZResult?, error _: (any Swift.Error)?)
  public func authTWNResident(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: TWNResidentResult?, error: (any Swift.Error)?)
  public func authJPNIDCard(frontImage: UIKit.UIImage?, backImage: UIKit.UIImage?, result: JPNIDCardResult?, error: (any Swift.Error)?)
  public func authJPNIDCardNFC(_ result: JPNIDCardNFCResult?, error: (any Swift.Error)?)
  public func authJPNDriverLicense(image: UIKit.UIImage?, result: JPNDriverLicenseResult?, error: (any Swift.Error)?)
  public func authJPNResidentCard(image: UIKit.UIImage?, result: JPNResidentCardResult?, error: (any Swift.Error)?)
  public func authUSAIDCard(image: UIKit.UIImage?, result: USAIDCardResult?, error: (any Swift.Error)?)
  public func authUSADriverLicense(image: UIKit.UIImage?, result: USADriverLicenseResult?, error: (any Swift.Error)?)
  public func authUSAVisitorVISA(image: UIKit.UIImage?, result: USAVisitorVISAResult?, error: (any Swift.Error)?)
  public func authIDNIDCard(image: UIKit.UIImage?, result: IDNIDCardResult?, error: (any Swift.Error)?)
  public func authIDNDriverLicense(image: UIKit.UIImage?, result: IDNDriverLicenseResult?, error: (any Swift.Error)?)
  public func personalPrivacyResult(result _: Swift.Bool)
  public func authenticateCompleted()
}
public protocol AuthMePlaygroundDelegate : ObjectiveC.NSObjectProtocol {
  func authmeLivenessViewControllerDidRecognize(result: AuthMeUI.AuthMeLivenessViewController.LivenessResult)
}
public protocol AuthMeNFCDelegate : ObjectiveC.NSObjectProtocol {
  func authmeNFCDidRecognize(result: MRZResult?, error: (any Swift.Error)?)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthMeManager : ObjectiveC.NSObject {
  @objc deinit
  public static let shared: AuthMeUI.AuthMeManager
  public static var version: Swift.String {
    get
  }
  public var UIConfig: AuthMeUI.AuthMeUIConfig
  public var KYCConfig: AuthMeUI.AuthmeKYCConfig
  public func setLocalizedBundle(with bundle: Foundation.Bundle)
  public func setLocalize(localize: AuthMeUI.AuthMeLocalize)
  public var localize: AuthMeUI.AuthMeLocalize {
    get
    set
  }
}
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup1 : AuthMeUI.DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
public enum AuthMeLocalize : Swift.String {
  case en
  case zh_Hant
  case jp
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AuthmeFeature : Swift.String {
  case IDCardFraud
  case IDCard
  case Passport
  case NFCPassport
  case DriverLicense
  case HealthCard
  case ResidentCard
  case JPID
  case JPNFCID
  case JPDriverLicense
  case JPResidentCard
  case USID
  case USDriverLicense
  case USVisitorVISA
  case IDID
  case IDDriverLicense
  case Liveness
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CardAccess {
  public var securityInfos: [AuthMeUI.SecurityInfo] {
    get
  }
  @objc deinit
}
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  public func getChild(_ child: Swift.Int) -> AuthMeUI.ASN1Item?
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> AuthMeUI.ASN1Item
  public func test()
  @objc deinit
}
extension AuthMeUI.AuthMeLivenessViewController : AVFoundation.AVCaptureDataOutputSynchronizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func dataOutputSynchronizer(_ synchronizer: AVFoundation.AVCaptureDataOutputSynchronizer, didOutput synchronizedDataCollection: AVFoundation.AVCaptureSynchronizedDataCollection)
}
extension AuthMeUI.AuthMeLivenessViewController {
  public enum `Type` {
    case passive
    case active
    public static func == (a: AuthMeUI.AuthMeLivenessViewController.`Type`, b: AuthMeUI.AuthMeLivenessViewController.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LivenessResult {
    case succeed(UIKit.UIImage)
    case failed
    case canceled
  }
}
extension AuthMeUI.AuthMeLivenessViewController : LivenessFlowDelegate {
  @_Concurrency.MainActor(unsafe) public func livenessDidStart()
  @_Concurrency.MainActor(unsafe) public func livenessDidNotifyMessage(message: Swift.String)
  @_Concurrency.MainActor(unsafe) public func livenessDidUpdateReconize(result: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func livenessDidFailureWith(error: FlowError, retryHandler: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor(unsafe) public func livenessDidRecognize(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func livenessDidFaceScale(direction: LivenessFlow.FaceScaleDirection.Direction)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyStage(log: LogFAS)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyUpload(log: LogUpload)
}
public enum JPNIndividualNumberCardError : Swift.Error, Swift.Equatable {
  case needPIN
  case incorrectPIN(Swift.Int)
  case incorrectPINFormat
  case UnexpectedError
  case UserCanceled
  case ConnectionError
  case MoreThanOneTagFound
  case ShouldReconnect
  case NFCNotSupported
  case TagNotValid
}
extension AuthMeUI.JPNIndividualNumberCardError {
  public static func == (lhs: AuthMeUI.JPNIndividualNumberCardError, rhs: AuthMeUI.JPNIndividualNumberCardError) -> Swift.Bool
}
public enum ISO7816Status {
  public static func localizedString(forStatusCode sw1: Swift.UInt8, _ sw2: Swift.UInt8) -> Swift.String
}
extension Swift.UInt8 {
  public func toString() -> Swift.String
  public func toHexString() -> Swift.String
}
@_hasMissingDesignatedInitializers public class TagReader {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ActiveAuthenticationInfo : AuthMeUI.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getSignatureAlgorithmOIDString() -> Swift.String?
  @objc deinit
}
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
  case ShouldReconnect
}
extension AuthMeUI.NFCPassportReaderError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
extension AuthMeUI.OpenSSLError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension AuthMeUI.PassiveAuthenticationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
public enum JPNIndividualNumberCardPINType {
  case digitalSignature
  case userAuthentication
  case cardInfoInputSupport
  case individualNumber
  public static func == (a: AuthMeUI.JPNIndividualNumberCardPINType, b: AuthMeUI.JPNIndividualNumberCardPINType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class COM : AuthMeUI.DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class AuthMeLivenessViewController : AuthMeUI.BaseViewController {
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any AuthMeUI.AuthMeAuthenticationDelegate)?
  @_Concurrency.MainActor(unsafe) public var uiParams: AuthMeUI.AuthMeLivenessUIParams?
  @_Concurrency.MainActor(unsafe) public var isInfoPageEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public let action: Action
  @_Concurrency.MainActor(unsafe) public var eventTrackingEnable: Swift.Bool
  @_Concurrency.MainActor(unsafe) public init(action: Action = .register(waitResult: true))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup14 : AuthMeUI.DataGroup {
  public var securityInfos: [AuthMeUI.SecurityInfo] {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup11 : AuthMeUI.DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  public var otherName: Swift.String? {
    get
  }
  @objc deinit
}
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: AuthMeUI.CertificateType, b: AuthMeUI.CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  public init?(with cert: Swift.OpaquePointer?)
  public func getItemsAsDict() -> [AuthMeUI.CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  public func getFingerprint() -> Swift.String?
  public func getNotBeforeDate() -> Swift.String?
  public func getNotAfterDate() -> Swift.String?
  public func getSerialNumber() -> Swift.String?
  public func getSignatureAlgorithm() -> Swift.String?
  public func getPublicKeyAlgorithm() -> Swift.String?
  public func getIssuerName() -> Swift.String?
  public func getSubjectName() -> Swift.String?
  @objc deinit
}
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: AuthMeUI.PassportAuthenticationStatus, b: AuthMeUI.PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var residenceAddress: Swift.String? {
    get
  }
  public var phoneNumber: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var documentSigningCertificate: AuthMeUI.X509Wrapper? {
    get
  }
  public var countrySigningCertificate: AuthMeUI.X509Wrapper? {
    get
  }
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [AuthMeUI.DataGroupId] {
    get
  }
  public var dataGroupsRead: [AuthMeUI.DataGroupId : AuthMeUI.DataGroup] {
    get
  }
  public var dataGroupHashes: [AuthMeUI.DataGroupId : AuthMeUI.DataGroupHash] {
    get
  }
  public var cardAccess: AuthMeUI.CardAccess? {
    get
  }
  public var BACStatus: AuthMeUI.PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: AuthMeUI.PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: AuthMeUI.PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  public var passportImage: UIKit.UIImage? {
    get
  }
  public var signatureImage: UIKit.UIImage? {
    get
  }
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: AuthMeUI.DataGroupId, dataGroup: AuthMeUI.DataGroup)
  public func getDataGroup(_ id: AuthMeUI.DataGroupId) -> AuthMeUI.DataGroup?
  public func dumpPassportData(selectedDataGroups: [AuthMeUI.DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [AuthMeUI.DataGroupId : [Swift.UInt8]]
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
public protocol AuthmeMenuCellable : UIKit.UIView {
  var titleLabel: UIKit.UILabel { get set }
  var isSelected: Swift.Bool { get set }
}
@_hasMissingDesignatedInitializers public class ChipAuthenticationPublicKeyInfo : AuthMeUI.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup2 : AuthMeUI.DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AuthMeOCRUIParams {
  public static func setWith(block: (AuthMeUI.AuthMeOCRUIParams) -> Swift.Void) -> AuthMeUI.AuthMeOCRUIParams
  @objc deinit
}
extension AuthMeUI.AuthMeOCRUIParams {
  @discardableResult
  final public func isColseButtonHidden(_ isHidden: Swift.Bool) -> Self
}
public enum NFCDeviceError : Swift.String, Swift.Error {
  case NotSupport
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AuthmeFeatureConfig {
  public static func setWith(_ block: (AuthMeUI.AuthmeFeatureConfig) -> Swift.Void) -> AuthMeUI.AuthmeFeatureConfig
  @objc deinit
}
extension AuthMeUI.AuthmeFeatureConfig {
  @discardableResult
  final public func needConfirm(_ needConfirm: Swift.Bool) -> Self
  @discardableResult
  final public func waterMark(_ waterMark: UIKit.UIImage) -> Self
  @discardableResult
  final public func isResultPageDisplayable(_ isResultPageDisplayable: Swift.Bool) -> Self
  @discardableResult
  final public func isResultEditable(_ isResultEditable: Swift.Bool) -> Self
  @discardableResult
  final public func isEventTrackingEnable(_ isEventTrackingEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isFraudIntroEnable(_ isFraudIntroEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isFraudHintAnimationEnable(_ isFraudHintAnimationEnable: Swift.Bool) -> Self
  @discardableResult
  final public func isNFCOffline(_ isNFCOffline: Swift.Bool) -> Self
}
public class PACEHandler {
  public init(cardAccess: AuthMeUI.CardAccess, tagReader: AuthMeUI.TagReader) throws
  public func doPACE(mrzKey: Swift.String, completed: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class LivenessPlaygroundViewController : AuthMeUI.BaseViewController, AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any AuthMeUI.AuthMePlaygroundDelegate)?
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)? = nil, handler: ((Swift.Result<Swift.Void, FlowError>) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
}
extension AuthMeUI.LivenessPlaygroundViewController : AVFoundation.AVCaptureDataOutputSynchronizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func dataOutputSynchronizer(_ synchronizer: AVFoundation.AVCaptureDataOutputSynchronizer, didOutput synchronizedDataCollection: AVFoundation.AVCaptureSynchronizedDataCollection)
}
extension AuthMeUI.LivenessPlaygroundViewController : LivenessPlaygroundFlowDelegate {
  @_Concurrency.MainActor(unsafe) public func livenessDidStart()
  @_Concurrency.MainActor(unsafe) public func livenessDidNotifyMessage(message: Swift.String)
  @_Concurrency.MainActor(unsafe) public func livenessDidUpdateReconize(result: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func livenessDidFailureWith(error: FlowError, retryHandler: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor(unsafe) public func livenessDidRecognize(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func livenessQueueDidUpload(currentCount: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func livenessDidFaceScale(direction: LivenessFlow.FaceScaleDirection.Direction)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyStage(log: LogFAS)
  @_Concurrency.MainActor(unsafe) public func livenessNotifyUpload(log: LogUpload)
}
extension AuthMeUI.LivenessPlaygroundViewController {
  public enum LivenessResult {
    case succeed(UIKit.UIImage)
    case failed
    case canceled
  }
}
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: AuthMeUI.TagReader)
  public func performBACAndGetSessionKeys(mrzKey: Swift.String, completed: @escaping (_ error: AuthMeUI.NFCPassportReaderError?) -> Swift.Void)
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
public enum TransitionStyle {
  case push
  case present
  public static func == (a: AuthMeUI.TransitionStyle, b: AuthMeUI.TransitionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FlowControl {
  public var isMenuEnabled: Swift.Bool
  public var authFlow: [AuthMeUI.AuthmeFeature]
  public init(isMenuEnabled: Swift.Bool, authFlow: [AuthMeUI.AuthmeFeature])
}
public protocol AuthmeCoordinatorDelegate : AnyObject {
  func coordinatorDidFinishScan()
}
public protocol AuthmeCoordinatorDataSource : AnyObject {
  func flow(accessTokenFor feature: AuthMeUI.AuthmeFeature, completion: ((Swift.String) -> Swift.Void)?)
  func flow(featureConfigFor feature: AuthMeUI.AuthmeFeature) -> AuthMeUI.AuthmeFeatureConfig
}
final public class AuthmeCoordinator {
  @objc deinit
  weak final public var authDelegate: (any AuthMeUI.AuthMeAuthenticationDelegate)?
  weak final public var delegate: (any AuthMeUI.AuthmeCoordinatorDelegate)?
  weak final public var dataSource: (any AuthMeUI.AuthmeCoordinatorDataSource)?
  public init(presenter: UIKit.UIViewController, flowControl: AuthMeUI.FlowControl)
  final public func start(with transitionStyle: AuthMeUI.TransitionStyle, animated: Swift.Bool)
}
@_hasMissingDesignatedInitializers public class ChipAuthenticationInfo : AuthMeUI.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
public enum NFCReconnectType {
  case disable
  case enable
  public static func == (a: AuthMeUI.NFCReconnectType, b: AuthMeUI.NFCReconnectType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol NFCSetting {
  var reconnectType: AuthMeUI.NFCReconnectType { get set }
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: AuthMeUI.PACEMappingType, b: AuthMeUI.PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PACEInfo : AuthMeUI.SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  public func getParameterId() -> Swift.Int?
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> AuthMeUI.PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> AuthMeUI.PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
public func mac(algoName: AuthMeUI.SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@_hasMissingDesignatedInitializers public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
public struct AuthMeUIConfig {
  public struct Customized {
    public struct ActionButton {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct ActionHint {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct CloseHint {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public struct BackHint {
      public let contentColor: UIKit.UIColor
      public init(contentColor: UIKit.UIColor)
    }
    public struct Scanner {
      public let contentColor: UIKit.UIColor
      public init(contentColor: UIKit.UIColor)
    }
    public struct StepButton {
      public let backgroundColor: UIKit.UIColor
      public let contentColor: UIKit.UIColor
      public init(backgroundColor: UIKit.UIColor, contentColor: UIKit.UIColor)
    }
    public let actionButton: AuthMeUI.AuthMeUIConfig.Customized.ActionButton
    public let actionHint: AuthMeUI.AuthMeUIConfig.Customized.ActionHint
    public let closeHint: AuthMeUI.AuthMeUIConfig.Customized.CloseHint
    public let backHint: AuthMeUI.AuthMeUIConfig.Customized.BackHint
    public let scanner: AuthMeUI.AuthMeUIConfig.Customized.Scanner
    public let stepButton: AuthMeUI.AuthMeUIConfig.Customized.StepButton
    public init(actionButton: AuthMeUI.AuthMeUIConfig.Customized.ActionButton, actionHint: AuthMeUI.AuthMeUIConfig.Customized.ActionHint, closeHint: AuthMeUI.AuthMeUIConfig.Customized.CloseHint, backHint: AuthMeUI.AuthMeUIConfig.Customized.BackHint, scanner: AuthMeUI.AuthMeUIConfig.Customized.Scanner, stepButton: AuthMeUI.AuthMeUIConfig.Customized.StepButton)
  }
  public var customized: AuthMeUI.AuthMeUIConfig.Customized
  public var showStatement: Swift.Bool
  public var isScreenRatioEnabled: Swift.Bool
  public init(customized: AuthMeUI.AuthMeUIConfig.Customized, showStatement: Swift.Bool)
}
@_hasMissingDesignatedInitializers final public class AuthMeLivenessUIParams {
  public static func setWith(block: (AuthMeUI.AuthMeLivenessUIParams) -> Swift.Void) -> AuthMeUI.AuthMeLivenessUIParams
  @objc deinit
}
extension AuthMeUI.AuthMeLivenessUIParams {
  @discardableResult
  final public func isColseButtonHidden(_ isHidden: Swift.Bool) -> Self
}
@_hasMissingDesignatedInitializers final public class AuthmeKYCConfig {
  public static func setWith(block: (AuthMeUI.AuthmeKYCConfig) -> Swift.Void) -> AuthMeUI.AuthmeKYCConfig
  @objc deinit
}
extension AuthMeUI.AuthmeKYCConfig {
  @discardableResult
  final public func isUploadFullFrameEnabaled(_ enabled: Swift.Bool) -> Self
}
@_hasMissingDesignatedInitializers public class DataGroup {
  public var datagroupType: AuthMeUI.DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> AuthMeUI.DataGroupId
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [AuthMeUI.DataGroupId]
  public typealias RawValue = Swift.Int
  public static var allCases: [AuthMeUI.DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: AuthMeUI.SecureMessagingSupportedAlgorithms, b: AuthMeUI.SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class SecureMessaging {
  public init(encryptionAlgorithm: AuthMeUI.SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DataGroup15 : AuthMeUI.DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
public struct NFCPassportSetting : AuthMeUI.NFCSetting {
  public var reconnectType: AuthMeUI.NFCReconnectType
  @_hasMissingDesignatedInitializers public class Builder {
    @discardableResult
    public func NFCShouldUseSecurityHashCheck(_ checked: Swift.Bool) -> AuthMeUI.NFCPassportSetting.Builder
    @discardableResult
    public func NFCSReconnectType(_ type: AuthMeUI.NFCReconnectType) -> AuthMeUI.NFCPassportSetting.Builder
    @objc deinit
  }
}
extension AuthMeUI.NFCPassportReaderError {
  public static func == (lhs: AuthMeUI.NFCPassportReaderError, rhs: AuthMeUI.NFCPassportReaderError) -> Swift.Bool
}
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(AuthMeUI.DataGroupId, Swift.Int)
  case error(AuthMeUI.NFCPassportReaderError)
  case successfulRead
}
extension AuthMeUI.NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
@objc public class PassportReader : ObjectiveC.NSObject {
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  public init(masterListURL: Foundation.URL? = nil)
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  @objc deinit
}
extension AuthMeUI.DocTypeEnum : Swift.Equatable {}
extension AuthMeUI.DocTypeEnum : Swift.Hashable {}
extension AuthMeUI.DocTypeEnum : Swift.RawRepresentable {}
extension AuthMeUI.AuthMeLocalize : Swift.Equatable {}
extension AuthMeUI.AuthMeLocalize : Swift.Hashable {}
extension AuthMeUI.AuthMeLocalize : Swift.RawRepresentable {}
extension AuthMeUI.AuthmeFeature : Swift.Equatable {}
extension AuthMeUI.AuthmeFeature : Swift.Hashable {}
extension AuthMeUI.AuthmeFeature : Swift.RawRepresentable {}
extension AuthMeUI.AuthMeLivenessViewController.`Type` : Swift.Equatable {}
extension AuthMeUI.AuthMeLivenessViewController.`Type` : Swift.Hashable {}
extension AuthMeUI.NFCPassportReaderError : Swift.Equatable {}
extension AuthMeUI.JPNIndividualNumberCardPINType : Swift.Equatable {}
extension AuthMeUI.JPNIndividualNumberCardPINType : Swift.Hashable {}
extension AuthMeUI.CertificateType : Swift.Equatable {}
extension AuthMeUI.CertificateType : Swift.Hashable {}
extension AuthMeUI.CertificateItem : Swift.Equatable {}
extension AuthMeUI.CertificateItem : Swift.Hashable {}
extension AuthMeUI.CertificateItem : Swift.RawRepresentable {}
extension AuthMeUI.PassportAuthenticationStatus : Swift.Equatable {}
extension AuthMeUI.PassportAuthenticationStatus : Swift.Hashable {}
extension AuthMeUI.NFCDeviceError : Swift.Equatable {}
extension AuthMeUI.NFCDeviceError : Swift.Hashable {}
extension AuthMeUI.NFCDeviceError : Swift.RawRepresentable {}
extension AuthMeUI.TransitionStyle : Swift.Equatable {}
extension AuthMeUI.TransitionStyle : Swift.Hashable {}
extension AuthMeUI.NFCReconnectType : Swift.Equatable {}
extension AuthMeUI.NFCReconnectType : Swift.Hashable {}
extension AuthMeUI.PACEMappingType : Swift.Equatable {}
extension AuthMeUI.PACEMappingType : Swift.Hashable {}
extension AuthMeUI.DataGroupId : Swift.Equatable {}
extension AuthMeUI.DataGroupId : Swift.Hashable {}
extension AuthMeUI.DataGroupId : Swift.RawRepresentable {}
extension AuthMeUI.SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension AuthMeUI.SecureMessagingSupportedAlgorithms : Swift.Hashable {}
